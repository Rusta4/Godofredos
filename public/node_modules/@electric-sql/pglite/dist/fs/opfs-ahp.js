import{f as B,g as z}from"../chunk-RBN4KMJ6.js";import{d as s,e as g,f as E,g as r,h as _,i as R}from"../chunk-Y3AVQXKT.js";R();var $="state.txt",G="data",T={DIR:16384,FILE:32768},H,v,O,M,y,b,m,x,F,P,S,n,C,D,k,w,f,I,W,j,L=class extends B{constructor(e,{initialPoolSize:t=1e3,maintainedPoolSize:o=100,debug:i=!1}={}){super(e,{debug:i});g(this,n);g(this,H);g(this,v);g(this,O);g(this,M);g(this,y);g(this,b,new Map);g(this,m,new Map);g(this,x,0);g(this,F,new Map);g(this,P,new Map);this.lastCheckpoint=0;this.checkpointInterval=1e3*60;this.poolCounter=0;g(this,S,new Set);this.initialPoolSize=t,this.maintainedPoolSize=o}async init(e,t){return await r(this,n,C).call(this),super.init(e,t)}async syncToFs(e=!1){await this.maybeCheckpointState(),await this.maintainPool(),e||this.flush()}async closeFs(){for(let e of s(this,m).values())e.close();s(this,y).flush(),s(this,y).close(),this.pg.Module.FS.quit()}async maintainPool(e){e=e||this.maintainedPoolSize;let t=e-this.state.pool.length,o=[];for(let i=0;i<t;i++)o.push(new Promise(async c=>{++this.poolCounter;let a=`${(Date.now()-1704063600).toString(16).padStart(8,"0")}-${this.poolCounter.toString(16).padStart(8,"0")}`,h=await s(this,O).getFileHandle(a,{create:!0}),d=await h.createSyncAccessHandle();s(this,b).set(a,h),s(this,m).set(a,d),r(this,n,k).call(this,{opp:"createPoolFile",args:[a]}),this.state.pool.push(a),c()}));for(let i=0;i>t;i--)o.push(new Promise(async c=>{let a=this.state.pool.pop();r(this,n,k).call(this,{opp:"deletePoolFile",args:[a]});let h=s(this,b).get(a);s(this,m).get(a)?.close(),await h.remove().then(()=>{s(this,b).delete(a),s(this,m).delete(a),c()})}));await Promise.all(o)}_createPoolFileState(e){this.state.pool.push(e)}_deletePoolFileState(e){let t=this.state.pool.indexOf(e);t>-1&&this.state.pool.splice(t,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let e=new TextEncoder().encode(JSON.stringify(this.state));s(this,y).truncate(0),s(this,y).write(e,{at:0}),s(this,y).flush(),this.lastCheckpoint=Date.now()}flush(){for(let e of s(this,S))try{e.flush()}catch{}s(this,S).clear()}chmod(e,t){r(this,n,D).call(this,{opp:"chmod",args:[e,t]},()=>{this._chmodState(e,t)})}_chmodState(e,t){let o=r(this,n,f).call(this,e);o.mode=t}close(e){let t=r(this,n,I).call(this,e);s(this,F).delete(e),s(this,P).delete(t)}fstat(e){let t=r(this,n,I).call(this,e);return this.lstat(t)}lstat(e){let t=r(this,n,f).call(this,e),o=t.type==="file"?s(this,m).get(t.backingFilename).getSize():0,i=4096;return{dev:0,ino:0,mode:t.mode,nlink:1,uid:0,gid:0,rdev:0,size:o,blksize:i,blocks:Math.ceil(o/i),atime:t.lastModified,mtime:t.lastModified,ctime:t.lastModified}}mkdir(e,t){r(this,n,D).call(this,{opp:"mkdir",args:[e,t]},()=>{this._mkdirState(e,t)})}_mkdirState(e,t){let o=r(this,n,w).call(this,e),i=o.pop(),c=[],a=this.state.root;for(let d of o){if(c.push(e),!Object.prototype.hasOwnProperty.call(a.children,d))if(t?.recursive)this.mkdir(c.join("/"));else throw new p("ENOENT","No such file or directory");if(a.children[d].type!=="directory")throw new p("ENOTDIR","Not a directory");a=a.children[d]}if(Object.prototype.hasOwnProperty.call(a.children,i))throw new p("EEXIST","File exists");let h={type:"directory",lastModified:Date.now(),mode:t?.mode||T.DIR,children:{}};a.children[i]=h}open(e,t,o){if(r(this,n,f).call(this,e).type!=="file")throw new p("EISDIR","Is a directory");let c=r(this,n,W).call(this);return s(this,F).set(c,e),s(this,P).set(e,c),c}readdir(e){let t=r(this,n,f).call(this,e);if(t.type!=="directory")throw new p("ENOTDIR","Not a directory");return Object.keys(t.children)}read(e,t,o,i,c){let a=r(this,n,I).call(this,e),h=r(this,n,f).call(this,a);if(h.type!=="file")throw new p("EISDIR","Is a directory");return s(this,m).get(h.backingFilename).read(new Uint8Array(t.buffer,o,i),{at:c})}rename(e,t){r(this,n,D).call(this,{opp:"rename",args:[e,t]},()=>{this._renameState(e,t,!0)})}_renameState(e,t,o=!1){let i=r(this,n,w).call(this,e),c=i.pop(),a=r(this,n,f).call(this,i.join("/"));if(!Object.prototype.hasOwnProperty.call(a.children,c))throw new p("ENOENT","No such file or directory");let h=r(this,n,w).call(this,t),d=h.pop(),l=r(this,n,f).call(this,h.join("/"));if(o&&Object.prototype.hasOwnProperty.call(l.children,d)){let u=l.children[d];s(this,m).get(u.backingFilename).truncate(0),this.state.pool.push(u.backingFilename)}l.children[d]=a.children[c],delete a.children[c]}rmdir(e){r(this,n,D).call(this,{opp:"rmdir",args:[e]},()=>{this._rmdirState(e)})}_rmdirState(e){let t=r(this,n,w).call(this,e),o=t.pop(),i=r(this,n,f).call(this,t.join("/"));if(!Object.prototype.hasOwnProperty.call(i.children,o))throw new p("ENOENT","No such file or directory");let c=i.children[o];if(c.type!=="directory")throw new p("ENOTDIR","Not a directory");if(Object.keys(c.children).length>0)throw new p("ENOTEMPTY","Directory not empty");delete i.children[o]}truncate(e,t=0){let o=r(this,n,f).call(this,e);if(o.type!=="file")throw new p("EISDIR","Is a directory");let i=s(this,m).get(o.backingFilename);if(!i)throw new p("ENOENT","No such file or directory");i.truncate(t),s(this,S).add(i)}unlink(e){r(this,n,D).call(this,{opp:"unlink",args:[e]},()=>{this._unlinkState(e,!0)})}_unlinkState(e,t=!1){let o=r(this,n,w).call(this,e),i=o.pop(),c=r(this,n,f).call(this,o.join("/"));if(!Object.prototype.hasOwnProperty.call(c.children,i))throw new p("ENOENT","No such file or directory");let a=c.children[i];if(a.type!=="file")throw new p("EISDIR","Is a directory");if(delete c.children[i],t){let h=s(this,m).get(a.backingFilename);h?.truncate(0),s(this,S).add(h),s(this,P).has(e)&&(s(this,F).delete(s(this,P).get(e)),s(this,P).delete(e))}this.state.pool.push(a.backingFilename)}utimes(e,t,o){r(this,n,D).call(this,{opp:"utimes",args:[e,t,o]},()=>{this._utimesState(e,t,o)})}_utimesState(e,t,o){let i=r(this,n,f).call(this,e);i.lastModified=o}writeFile(e,t,o){let i=r(this,n,w).call(this,e),c=i.pop(),a=r(this,n,f).call(this,i.join("/"));if(Object.prototype.hasOwnProperty.call(a.children,c)){let l=a.children[c];l.lastModified=Date.now(),r(this,n,k).call(this,{opp:"setLastModified",args:[e,l.lastModified]})}else{if(this.state.pool.length===0)throw new Error("No more file handles available in the pool");let l={type:"file",lastModified:Date.now(),mode:o?.mode||T.FILE,backingFilename:this.state.pool.pop()};a.children[c]=l,r(this,n,k).call(this,{opp:"createFileNode",args:[e,l]})}let h=a.children[c],d=s(this,m).get(h.backingFilename);t.length>0&&(d.write(typeof t=="string"?new TextEncoder().encode(t):new Uint8Array(t),{at:0}),e.startsWith("/pg_wal")&&s(this,S).add(d))}_createFileNodeState(e,t){let o=r(this,n,w).call(this,e),i=o.pop(),c=r(this,n,f).call(this,o.join("/"));c.children[i]=t;let a=this.state.pool.indexOf(t.backingFilename);return a>-1&&this.state.pool.splice(a,1),t}_setLastModifiedState(e,t){let o=r(this,n,f).call(this,e);o.lastModified=t}write(e,t,o,i,c){let a=r(this,n,I).call(this,e),h=r(this,n,f).call(this,a);if(h.type!=="file")throw new p("EISDIR","Is a directory");let d=s(this,m).get(h.backingFilename);if(!d)throw new p("EBADF","Bad file descriptor");let l=d.write(new Uint8Array(t,o,i),{at:c});return a.startsWith("/pg_wal")&&s(this,S).add(d),l}};H=new WeakMap,v=new WeakMap,O=new WeakMap,M=new WeakMap,y=new WeakMap,b=new WeakMap,m=new WeakMap,x=new WeakMap,F=new WeakMap,P=new WeakMap,S=new WeakMap,n=new WeakSet,C=async function(){E(this,H,await navigator.storage.getDirectory()),E(this,v,await r(this,n,j).call(this,this.dataDir,{create:!0})),E(this,O,await r(this,n,j).call(this,G,{from:s(this,v),create:!0})),E(this,M,await s(this,v).getFileHandle($,{create:!0})),E(this,y,await s(this,M).createSyncAccessHandle());let e=new ArrayBuffer(s(this,y).getSize());s(this,y).read(e,{at:0});let t,o=new TextDecoder().decode(e).split(`
`),i=!1;try{t=JSON.parse(o[0])}catch{t={root:{type:"directory",lastModified:Date.now(),mode:T.DIR,children:{}},pool:[]},s(this,y).truncate(0),s(this,y).write(new TextEncoder().encode(JSON.stringify(t)),{at:0}),i=!0}this.state=t;let c=o.slice(1).filter(Boolean).map(l=>JSON.parse(l));for(let l of c){let u=`_${l.opp}State`;if(typeof this[u]=="function")try{this[u].bind(this)(...l.args)}catch(N){console.warn("Error applying OPFS AHP WAL entry",l,N)}}let a=[],h=async l=>{if(l.type==="file")try{let u=await s(this,O).getFileHandle(l.backingFilename),N=await u.createSyncAccessHandle();s(this,b).set(l.backingFilename,u),s(this,m).set(l.backingFilename,N)}catch(u){console.error("Error opening file handle for node",l,u)}else for(let u of Object.values(l.children))a.push(h(u))};await h(this.state.root);let d=[];for(let l of this.state.pool)d.push(new Promise(async u=>{s(this,b).has(l)&&console.warn("File handle already exists for pool file",l);let N=await s(this,O).getFileHandle(l),U=await N.createSyncAccessHandle();s(this,b).set(l,N),s(this,m).set(l,U),u()}));await Promise.all([...a,...d]),await this.maintainPool(i?this.initialPoolSize:this.maintainedPoolSize)},D=function(e,t){let o=r(this,n,k).call(this,e);try{t()}catch(i){throw s(this,y).truncate(o),i}},k=function(e){let t=JSON.stringify(e),o=new TextEncoder().encode(`
${t}`),i=s(this,y).getSize();return s(this,y).write(o,{at:i}),s(this,S).add(s(this,y)),i},w=function(e){return e.split("/").filter(Boolean)},f=function(e,t){let o=r(this,n,w).call(this,e),i=t||this.state.root;for(let c of o){if(i.type!=="directory")throw new p("ENOTDIR","Not a directory");if(!Object.prototype.hasOwnProperty.call(i.children,c))throw new p("ENOENT","No such file or directory");i=i.children[c]}return i},I=function(e){let t=s(this,F).get(e);if(!t)throw new p("EBADF","Bad file descriptor");return t},W=function(){let e=++_(this,x)._;for(;s(this,F).has(e);)_(this,x)._++;return e},j=async function(e,t){let o=r(this,n,w).call(this,e),i=t?.from||s(this,H);for(let c of o)i=await i.getDirectoryHandle(c,{create:t?.create});return i};var p=class extends Error{constructor(A,e){super(e),typeof A=="number"?this.code=A:typeof A=="string"&&(this.code=z[A])}};export{L as OpfsAhpFS};
//# sourceMappingURL=opfs-ahp.js.map