import{a as Ee,b as re,c as z,d as v,e as V}from"./chunk-RBN4KMJ6.js";import{a as me}from"./chunk-NMYRYYP2.js";import"./chunk-EL7DUS2A.js";import{a as ne,b as oe,c as ae,d as le,e as ce,f as _e,g as J,h as Fe,m as Te,p as Se,q as ue,r as de,s as pe,t as fe,u as Me,v as Oe}from"./chunk-IZM3GSNN.js";import{c as ve,d as n,e as p,f as y,g as B,i as f}from"./chunk-Y3AVQXKT.js";f();f();f();var Ne=new Error("timeout while waiting for mutex to become available"),Ue=new Error("mutex already locked"),Ae=new Error("request for lock canceled"),Re=function(i,t,e,s){function o(r){return r instanceof e?r:new e(function(c){c(r)})}return new(e||(e=Promise))(function(r,c){function m(u){try{d(s.next(u))}catch(a){c(a)}}function l(u){try{d(s.throw(u))}catch(a){c(a)}}function d(u){u.done?r(u.value):o(u.value).then(m,l)}d((s=s.apply(i,t||[])).next())})},Z=class{constructor(t,e=Ae){this._value=t,this._cancelError=e,this._weightedQueues=[],this._weightedWaiters=[]}acquire(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise((e,s)=>{this._weightedQueues[t-1]||(this._weightedQueues[t-1]=[]),this._weightedQueues[t-1].push({resolve:e,reject:s}),this._dispatch()})}runExclusive(t,e=1){return Re(this,void 0,void 0,function*(){let[s,o]=yield this.acquire(e);try{return yield t(s)}finally{o()}})}waitForUnlock(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise(e=>{this._weightedWaiters[t-1]||(this._weightedWaiters[t-1]=[]),this._weightedWaiters[t-1].push(e),this._dispatch()})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(t){this._value=t,this._dispatch()}release(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);this._value+=t,this._dispatch()}cancel(){this._weightedQueues.forEach(t=>t.forEach(e=>e.reject(this._cancelError))),this._weightedQueues=[]}_dispatch(){var t;for(let e=this._value;e>0;e--){let s=(t=this._weightedQueues[e-1])===null||t===void 0?void 0:t.shift();if(!s)continue;let o=this._value,r=e;this._value-=e,e=this._value+1,s.resolve([o,this._newReleaser(r)])}this._drainUnlockWaiters()}_newReleaser(t){let e=!1;return()=>{e||(e=!0,this.release(t))}}_drainUnlockWaiters(){for(let t=this._value;t>0;t--)this._weightedWaiters[t-1]&&(this._weightedWaiters[t-1].forEach(e=>e()),this._weightedWaiters[t-1]=[])}},De=function(i,t,e,s){function o(r){return r instanceof e?r:new e(function(c){c(r)})}return new(e||(e=Promise))(function(r,c){function m(u){try{d(s.next(u))}catch(a){c(a)}}function l(u){try{d(s.throw(u))}catch(a){c(a)}}function d(u){u.done?r(u.value):o(u.value).then(m,l)}d((s=s.apply(i,t||[])).next())})},M=class{constructor(t){this._semaphore=new Z(1,t)}acquire(){return De(this,void 0,void 0,function*(){let[,t]=yield this._semaphore.acquire();return t})}runExclusive(t){return this._semaphore.runExclusive(()=>t())}isLocked(){return this._semaphore.isLocked()}waitForUnlock(){return this._semaphore.waitForUnlock()}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}};f();import Be from"./postgres.js";var ye=Be;f();f();var L=class extends V{async init(t,e){return this.pg=t,{emscriptenOpts:{...e,preRun:[...e.preRun||[],o=>{let r=o.FS.filesystems.IDBFS;o.FS.mkdir("/pglite"),o.FS.mkdir(`/pglite/${this.dataDir}`),o.FS.mount(r,{},`/pglite/${this.dataDir}`),o.FS.symlink(`/pglite/${this.dataDir}`,v)}]}}}initialSyncFs(){return new Promise((t,e)=>{this.pg.Module.FS.syncfs(!0,s=>{s?e(s):t()})})}syncToFs(t){return new Promise((e,s)=>{this.pg.Module.FS.syncfs(!1,o=>{o?s(o):e()})})}async closeFs(){let t=this.pg.Module.FS.filesystems.IDBFS.dbs[this.dataDir];t&&t.close(),this.pg.Module.FS.quit()}};f();var q=class extends V{async closeFs(){this.pg.Module.FS.quit()}};function he(i){let t;if(i?.startsWith("file://")){if(i=i.slice(7),!i)throw new Error("Invalid dataDir, must be a valid path");t="nodefs"}else i?.startsWith("idb://")?(i=i.slice(6),t="idbfs"):i?.startsWith("opfs-ahp://")?(i=i.slice(11),t="opfs-ahp"):!i||i?.startsWith("memory://")?t="memoryfs":t="nodefs";return{dataDir:i,fsType:t}}async function ge(i,t){let e;if(i&&t==="nodefs"){let{NodeFS:s}=await import("./fs/nodefs.js");e=new s(i)}else if(i&&t==="idbfs")e=new L(i);else if(i&&t==="opfs-ahp"){let{OpfsAhpFS:s}=await import("./fs/opfs-ahp.js");e=new s(i)}else e=new q;return e}f();var we=ve(Ee(),1);async function ee(i){if(ue){let t=await import("fs"),e=await import("zlib"),{Writable:s}=await import("stream"),{pipeline:o}=await import("stream/promises");if(!t.existsSync(i))throw new Error(`Extension bundle not found: ${i}`);let r=e.createGunzip(),c=[];return await o(t.createReadStream(i),r,new s({write(m,l,d){c.push(m),d()}})),new Blob(c)}else{let t=await fetch(i.toString());if(!t.ok||!t.body)return null;if(t.headers.get("Content-Encoding")==="gzip")return t.blob();{let e=new DecompressionStream("gzip");return new Response(t.body.pipeThrough(e)).blob()}}}async function be(i,t){for(let e in i.pg_extensions){let s;try{s=await i.pg_extensions[e]}catch(o){console.error("Failed to fetch extension:",e,o);continue}if(s){let o=new Uint8Array(await s.arrayBuffer());Ie(i,e,o,t)}else console.error("Could not get binary data for extension:",e)}}function Ie(i,t,e,s){we.default.untar(e).forEach(r=>{if(!r.name.startsWith(".")){let c=i.WASM_PREFIX+"/"+r.name;if(r.name.endsWith(".so")){let m=(...d)=>{s("pgfs:ext OK",c,d)},l=(...d)=>{s("pgfs:ext FAIL",c,d)};i.FS.createPreloadedFile(ke(c),r.name.split("/").pop().slice(0,-3),r.data,!0,!0,m,l,!1)}else i.FS.writeFile(c,r.data)}})}function ke(i){let t=i.lastIndexOf("/");return t>0?i.slice(0,t):i}var I,O,A,k,N,K,X,Y,U,$,C,Q,R,F,w,D,P,Pe,W,te=class te extends me{constructor(e={},s={}){super();p(this,P);p(this,I,!1);p(this,O,!1);p(this,A,!1);p(this,k,!1);p(this,N,!1);p(this,K,new M);p(this,X,new M);p(this,Y,new M);p(this,U,!1);this.debug=0;p(this,$);p(this,C,[]);p(this,Q,new J);p(this,R);p(this,F);p(this,w,new Map);p(this,D,new Set);typeof e=="string"?s={dataDir:e,...s}:s=e,this.dataDir=s.dataDir,s?.debug!==void 0&&(this.debug=s.debug),s?.relaxedDurability!==void 0&&y(this,N,s.relaxedDurability),y(this,$,s.extensions??{}),this.waitReady=B(this,P,Pe).call(this,s??{})}static async create(e,s){let o=typeof e=="string"?{dataDir:e,...s??{}}:e??{},r=new te(o);return await r.waitReady,r}get Module(){return this.mod}get ready(){return n(this,I)&&!n(this,O)&&!n(this,A)}get closed(){return n(this,A)}async close(){await this._checkReady(),y(this,O,!0);for(let e of n(this,C))await e();try{await this.execProtocol(ne.end()),this.mod._pg_shutdown()}catch(e){let s=e;if(!(s.name==="ExitStatus"&&s.status===0))throw e}await this.fs.closeFs(),y(this,A,!0),y(this,O,!1)}async[Symbol.asyncDispose](){await this.close()}async _handleBlob(e){y(this,R,e?await e.arrayBuffer():void 0)}async _cleanupBlob(){y(this,R,void 0)}async _getWrittenBlob(){if(!n(this,F))return;let e=new Blob(n(this,F));return y(this,F,void 0),e}async _checkReady(){if(n(this,O))throw new Error("PGlite is closing");if(n(this,A))throw new Error("PGlite is closed");n(this,I)||await this.waitReady}async execProtocolRaw(e,{syncToFs:s=!0}={}){let o=e.length,r=this.mod;r._interactive_write(o),r.HEAPU8.set(e,1),r._interactive_one();let c=o+2,m=c+r._interactive_read(),l=r.HEAPU8.subarray(c,m);return s&&await this.syncToFs(),l}async execProtocol(e,{syncToFs:s=!0,throwOnError:o=!0,onNotice:r}={}){let c=await this.execProtocolRaw(e,{syncToFs:s}),m=[];return n(this,Q).parse(c,l=>{if(l instanceof oe){if(y(this,Q,new J),o)throw l}else if(l instanceof ce)this.debug>0&&console.warn(l),r&&r(l);else if(l instanceof le)switch(l.text){case"BEGIN":y(this,k,!0);break;case"COMMIT":case"ROLLBACK":y(this,k,!1);break}else if(l instanceof ae){let d=n(this,w).get(l.channel);d&&d.forEach(u=>{queueMicrotask(()=>u(l.payload))}),n(this,D).forEach(u=>{queueMicrotask(()=>u(l.channel,l.payload))})}m.push([l,c])}),m}isInTransaction(){return n(this,k)}async syncToFs(){if(n(this,U))return;y(this,U,!0);let e=async()=>{await n(this,Y).runExclusive(async()=>{y(this,U,!1),await this.fs.syncToFs(n(this,N))})};n(this,N)?e():await e()}async listen(e,s){return n(this,w).has(e)||n(this,w).set(e,new Set),n(this,w).get(e).add(s),await this.exec(`LISTEN "${e}"`),async()=>{await this.unlisten(e,s)}}async unlisten(e,s){s?(n(this,w).get(e)?.delete(s),n(this,w).get(e)?.size===0&&(await this.exec(`UNLISTEN "${e}"`),n(this,w).delete(e))):(await this.exec(`UNLISTEN "${e}"`),n(this,w).delete(e))}onNotification(e){return n(this,D).add(e),()=>{n(this,D).delete(e)}}offNotification(e){n(this,D).delete(e)}async dumpDataDir(e){let s=this.dataDir?.split("/").pop()??"pgdata";return this.fs.dumpTar(s,e)}_runExclusiveQuery(e){return n(this,K).runExclusive(e)}_runExclusiveTransaction(e){return n(this,X).runExclusive(e)}};I=new WeakMap,O=new WeakMap,A=new WeakMap,k=new WeakMap,N=new WeakMap,K=new WeakMap,X=new WeakMap,Y=new WeakMap,U=new WeakMap,$=new WeakMap,C=new WeakMap,Q=new WeakMap,R=new WeakMap,F=new WeakMap,w=new WeakMap,D=new WeakMap,P=new WeakSet,Pe=async function(e){if(e.fs)this.fs=e.fs;else{let{dataDir:a,fsType:h}=he(e.dataDir);this.fs=await ge(a,h)}let s={},o=[],r=[`PGDATA=${v}`,`PREFIX=${z}`,`PGUSER=${e.username??"postgres"}`,`PGDATABASE=${e.database??"template1"}`,"MODE=REACT","REPL=N",...this.debug?["-d",this.debug.toString()]:[]];e.wasmModule||de();let c=e.fsBundle?e.fsBundle.arrayBuffer():fe(),m;c.then(a=>{m=a});let l={WASM_PREFIX:z,arguments:r,INITIAL_MEMORY:e.initialMemory,noExitRuntime:!0,...this.debug>0?{print:console.info,printErr:console.error}:{print:()=>{},printErr:()=>{}},instantiateWasm:(a,h)=>(pe(a,e.wasmModule).then(({instance:g,module:b})=>{h(g,b)}),{}),getPreloadedPackage:(a,h)=>{if(a==="postgres.data"){if(m.byteLength!==h)throw new Error(`Invalid FS bundle size: ${m.byteLength} !== ${h}`);return m}throw new Error(`Unknown package: ${a}`)},preRun:[a=>{let h=a.FS.makedev(64,0),g={open:b=>{},close:b=>{},read:(b,G,T,S,x)=>{let se=n(this,R);if(!se)throw new Error("No /dev/blob File or Blob provided to read from");let H=new Uint8Array(se);if(x>=H.length)return 0;let ie=Math.min(H.length-x,S);for(let j=0;j<ie;j++)G[T+j]=H[x+j];return ie},write:(b,G,T,S,x)=>(n(this,F)??y(this,F,[]),n(this,F).push(G.slice(T,T+S)),S),llseek:(b,G,T)=>{let S=n(this,R);if(!S)throw new Error("No /dev/blob File or Blob provided to llseek");let x=G;if(T===1?x+=b.position:T===2&&(x=new Uint8Array(S).length),x<0)throw new a.FS.ErrnoError(28);return x}};a.FS.registerDevice(h,g),a.FS.mkdev("/dev/blob",h)}]},{emscriptenOpts:d}=await this.fs.init(this,l);l=d;for(let[a,h]of Object.entries(n(this,$)))if(h instanceof URL)s[a]=ee(h);else{let g=await h.setup(this,l);if(g.emscriptenOpts&&(l=g.emscriptenOpts),g.namespaceObj){let b=this;b[a]=g.namespaceObj}g.bundlePath&&(s[a]=ee(g.bundlePath)),g.init&&o.push(g.init),g.close&&n(this,C).push(g.close)}if(l.pg_extensions=s,await c,this.mod=await ye(l),await this.fs.initialSyncFs(),e.loadDataDir){if(this.mod.FS.analyzePath(v+"/PG_VERSION").exists)throw new Error("Database already exists, cannot load from tarball");B(this,P,W).call(this,"pglite: loading data from tarball"),await re(this.mod.FS,e.loadDataDir,v)}this.mod.FS.analyzePath(v+"/PG_VERSION").exists?B(this,P,W).call(this,"pglite: found DB, resuming"):B(this,P,W).call(this,"pglite: no db"),await be(this.mod,(...a)=>B(this,P,W).call(this,...a));let u=this.mod._pg_initdb();if(!u)throw new Error("INITDB failed to return value");if(u&1)throw new Error("INITDB failed");if(u&2){let a=e.username??"postgres",h=e.database??"template1";if(u&4){if(!(u&12))throw new Error("Invalid db/user combination")}else if(h!=="template1"&&a!=="postgres")throw new Error("INITDB created a new datadir, but an alternative db/user was requested")}await this.syncToFs(),y(this,I,!0),await this.exec("SET search_path TO public;"),await this._initArrayTypes();for(let a of o)await a()},W=function(...e){this.debug>0&&console.log(...e)};var xe=te;f();export{L as IdbFs,q as MemoryFS,M as Mutex,xe as PGlite,Oe as formatQuery,_e as messages,Se as parse,Fe as protocol,Te as types,Me as uuid};
//# sourceMappingURL=index.js.map